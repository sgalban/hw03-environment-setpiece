# CIS 566 Homework 3: Environment Setpiece

## Overview
My raymarched scene features an hourglass, with animated sand, in the middle of a small interior space.
The scene is composed of a variety of SDF primitives, combined through a several different methods,
multiple different materials, and several directional lights. Note that the scene was developed and tested using Firefox 65.0 on MacOS 10.12.6., and was developed locally on my machine, not using ShaderToy.

## Structs
In order to keep my code organized and robust, I introduced a large number of structs that could be used in a variety of situations. These include:
  - SDFData, which is returned by the totalSdf function when raymarching or calculating normals. This contains the distance to the nearest geometry, as usual, but also includes material data (see below) that can be used to color the surface. When a ray gets close enough to geometry to render it, the returned SDFData contains the material data of the closest surface.
  - Surface, which encapsulates the data relating to a point hit by the marched ray. Most importantly, this includes the position the ray hit the surface, the normal at that point, the direction of the ray that hit the surface, and the material of the surface (which is copied from the SDFData). Taken together, this information alone can be used to calculate the color of the fragment.
  - Light, which contains all the data pertaining to a single light (direction, color, etc.) There is a field for the type of light, as I was considering including point lights as well as directional lights, but I was unable to implement this due to time constraints.
  - Material, which contains all the shading data global to the surface (although certain materials are edited after raymarching to add variation across a single surface). Properties include material type (which are all described below), base color, shininess, reflexivity, ior, and attenuation. These properties only apply for certain material types.

## Geometry
The geometry in the scene is composed of multiple different SDFs, many of which were present in the previous homework. These include spheres, ellipsoids, boxes, capsules, cones, cylinders, etc. As with the previous assignment, I implemented the union, intersection, and difference operators (which can optionally include a smoothing coefficient). I also implemented an inset operator to hollow out an SDF and give it a thickness. In particular;
  - The hourglass was created using a large number of shapes and operations, too many to explain in detail. Basically, the glass was made with 2 cones, and spheres that were smooth-unioned, and them subtracted from boxes to make sure the ends were flat. It was then inset to make it hollow. The stand used several spheres, capsules, ellipsoids and toruses smoothed together, along with cylinders and cones for the bases. Some subtraction was used to add detail. The sand was simply made using smooth-unioned spheres, as wel as some smooth subtraction, and was then intersected with the hull of the glass to make sure it fits inside. The position of these spheres are animated to create the sand emptying from the top into the bottom.
  - The tabletop is simply a box blended with a cylinder with similar dimensions, giving it a rounded appearance, but still with some sharp corners.
  - The floor is simply a box with a small height.

## Materials
The bulk of my time was spent working on the different materials in my scene, as there are quite a few of them of varying complexity:
  - There is a simple lambert shader, however, it just calculates the flat color, as the shadow calculation is able to light it as needed, and using both the lambertion shader and the shadow made the objects appear much darker than neccessary. The sand uses a modified lambertian shader that colors the fragments using a high frequency FBM. The noise function of the top half of the sand moves downward to give the appearance that the sand is funneling down (this is easier to see if the time multiplier is increased)
  - A simple blinn-phong shader adds the specular highlight to the lambertian color. This highlight is used repeatedly in most other shaders. This shader, along with all the other ones, use normals calculated from the total distance field gradient. The power used in the highlight is determined by the material's shininess.
  - A glossy shader takes the blinn-phong color, an adds reflections to it. This is done by casting a separate ray after the initial raymarching, with an origin at the hit point, and a direction calculated by GLSL's built in reflect() function. This second ray hits another peice of geometry (or the background), calculates its color, and sets the color of the original surface to that one. However, GLSL doesn't allow for recursion, so I had to duplicate my color calculation function. However, every reflected surface is rendered with either a blinnphong or lambertian shader, as using more complex shaders within the reflection would be too expensive without adding too much to the scene. How reflective a surface is depends on the material's reflexivity value. If it's 1.0, the color is based entirely on the reflection (and the specular highlight). At 0.0, the material might as well be blinn-phong. At 0.5, the blinn phong and full reflective surface are linearly interpolated by the approximated fresnel coefficient (found via a simple dot product).
  - The refractive shader was by far the most difficult shader to implement, and took many different steps: 
    -After the initial raycast, another ray is cast, which has an origin at the hit point, and its direction is determined with GLSL's refract() function, using the material's index of refraction value (note that I originally didn't know that this method existed, so I manually calculated the refraction vector, which was a terrible experience that I would not recommend to anyone). At small angles, in certain situations, the implementation of refract() runs into imaginary numbers, so it returns the zero vector, creating rings of black in some surfaces. To rememedy this, I check if this happens, then I calculate the vector manually, clamping the negative radicand to 0. It's not perfect, but I determined that it's good enough for the purposes of this assignment.
    - This cast ray should, except in certain edge cases, be traveling through the refractive object at this point, it stops when it hits the other side of the surface.
    - Another ray is cast, also using the refract() function. Because it's leaving the medium, the ior is inversed during this computation. The resulting ray will then hit another surface, and the color of the fragment will be determined from there.
      - Like the glossy shader, these "recursively" calculated colors are simplified to avoid even more complexity. However, as it is an integral part of my scene, I did implement another "recursive" refractive call. This allows you to see through both layers of the hourglass, both of which are refractive.
    - I can easily calculate the distance the ray went through the refractive object by looking at where the first 2 rays hit. I use the inverse exponential of this distance (along with the material's attenuation value) to mix the refracted color with the base color. This gives the objects some sort of turbidity that increases realistically at certain angles. It is most easily seen at the edges of the hourglass, where the glass appears more green than anything else (as is true with actual glass).
  - Some other shaders based on the previous ones were created to add procedural textures and perturb normals based on them. These include:
    - The sand, which was decribed above
    - The wood table. An FBM was stretched out along a single axis, and was then used to modify the color and normals of the fragments. The normal perturbence can be seen in the reflection if you look clostly.
    - The wood floor. The different planks were calculated as offset cells. The seed of all the other noise and toolbox functions then use the corner of each plank to make them appear separate. First, a simple 1-dimensional sawtooth function is calculated. It's perturbed using some stretched FBM to give the planks a basic wood texture. Another higher frequency FBM is then stretched out and overlaid across the planks to add some grainy detail (similarly to the table). Note that this grain is also perturbed using the same perturbance used to warp the sawtooth. The output value is then used as an iterpolation in a cosine color pallette, and is used as a bump-map. Unlike the table though, the floor is just a blinn-phong.
